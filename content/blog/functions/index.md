---
title: "Functions"
date: "2021-10-29"
category: "dev"
emoji: "ðŸ¶"
---

åœ¨å­¦ä¹ ç”¨ C å†™ä¸€ä¸ª Lisp è§£é‡Šå™¨çš„è¿‡ç¨‹ä¸­, å­¦åˆ° Functions è¿™ä¸€ç« èŠ‚, æ˜Žç™½äº†å‡½æ•°æ˜¯å¦‚ä½•è¢«æ‰§è¡Œçš„, å¯¹å…¶å†…å­˜ç»“æž„ä¹Ÿæœ‰äº†ä¸€å®šçš„è®¤çŸ¥.

é¦–å…ˆ, ä»»ä½•æ•°æ®éƒ½æ˜¯ä¸€ä¸ª `lval` ç»“æž„ä½“, æ¯”å¦‚æ•°å­—/ç¬¦å·/é”™è¯¯/å‡½æ•°/Sè¡¨è¾¾å¼/Qè¡¨è¾¾å¼. å…¶ä¸­ä»»æ„ç¬¦å·æ¯”å¦‚ `+-*/` æˆ–è€… `join tail head` è¿™äº›å…³é”®å­—, ç”šè‡³ `a b c d` è¿™ç§éƒ½å¯ç®—ä½œç¬¦å·. é‚£å¦‚ä½•çŸ¥é“è¿™äº›ç¬¦å·ä»£è¡¨ä»€ä¹ˆå‘¢? æ‰€ä»¥å°±éœ€è¦æœ‰ä¸€ä¸ªçŽ¯å¢ƒ `lenv`. å…¨å±€åˆå§‹åŒ–ä¸€ä¸ª `lenv`, å°†é»˜è®¤çš„ `+-*/ join tail head` ç­‰å…³é”®å­—æ”¾è¿›åŽ», å¯¹åº”ä¸Šå…¶ç›¸å…³çš„å‡½æ•°. é‚£ `a b c d` è¿™ç§ç¬¦å·, å¦‚æžœç”¨æˆ·é€šè¿‡ `def` å…³é”®å­—æ”¾è¿›çŽ¯å¢ƒä¸­, é‚£å°±å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„å€¼. å¦‚æžœæ‰¾ä¸åˆ°, åˆ™æŠ›å‡ºé”™è¯¯.

è¦æƒ³å®šä¹‰è‡ªå·±çš„å‡½æ•°, åˆ™éœ€è¦ lambda è¡¨è¾¾å¼, å…¶ä¹Ÿå±žäºŽ `lval`. lambda è¡¨è¾¾å¼ä¹Ÿå±žäºŽå‡½æ•°, åªä¸è¿‡æ²¡æœ‰å†…å®šçš„å‡½æ•°, åªæœ‰å‚æ•°å’Œå‡½æ•°ä½“. å‚æ•°å’Œå‡½æ•°ä½“ä¹Ÿæ˜¯ `lval` ç±»åž‹. äºŽæ˜¯ä¸‹é¢å…·ä½“è®²ä¸€è®²å‡½æ•°å¦‚ä½•æ‰§è¡Œçš„. å…³é”®ä»£ç å¦‚ä¸‹:

```c
lval* lval_call(lenv* e, lval* f, lval* a) {
  if (f->builtin) { return f->builtin(e, a); }
  int given = a->count;
  int total = f->formals->count;
  while (a->count) {
    if (f->formals->count == 0) {
      lval_del(a); return lval_err(
        "Function passed too many arguments. "
        "Got %i, Expected %i.", given, total);
    }
    lval* sym = lval_pop(f->formals, 0);
    lval* val = lval_pop(a, 0);
    lenv_put(f->env, sym, val);
    lval_del(sym); lval_del(val);
  }
  lval_del(a);
  if (f->formals->count == 0) {
    f->env->par = e;
    return builtin_eval(
      f->env, lval_add(lval_sexpr(), lval_copy(f->body)));
  } else {
    return lval_copy(f);
  }
}
```

é¦–å…ˆä¸€ä¸ªå‡½æ•°å¦‚æžœæœ‰å†…å®šæ‰§è¡Œå‡½æ•°, æ¯”å¦‚åŠ å‡ä¹˜é™¤, åˆ™ç›´æŽ¥æ‰§è¡Œå…¶å†…å®šå‡½æ•°. å¦åˆ™å®ƒå°±æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„å‡½æ•°. å‡½æ•°æ‰§è¡Œéœ€è¦å®žå‚å’Œå½¢å‚. å¯¹äºŽå½¢å‚, å…¶ä¸ºæœªçŸ¥çš„ç¬¦å·, ä¸Šé¢è®²åˆ°æœ‰å…¨å±€çŽ¯å¢ƒ, é‚£ä¹ˆå‡½æ•°ä¹Ÿæœ‰è‡ªå·±çš„å±€éƒ¨çŽ¯å¢ƒ, å±€éƒ¨çŽ¯å¢ƒçš„ parent æ˜¯å…¨å±€çŽ¯å¢ƒ. æ‰€ä»¥åœ¨éåŽ†ä¸­, å°†å®žå‚å’Œå½¢å‚ä¸€ä¸€å¯¹åº”åˆ°å‡½æ•°çš„å±€éƒ¨å˜é‡ä¸­, å¯¹å½¢å‚çš„ç¬¦å·èµ‹å€¼. æœ€ç»ˆå†è¿›è¡Œ `eval` å°†å‡½æ•°ä½“è¿›è¡Œæ‰§è¡Œ, æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°çš„ç¬¦å·åŽ»å‡½æ•°è‡ªå·±çš„çŽ¯å¢ƒä¸­å¯»æ‰¾, å¦‚æžœæ‰¾ä¸åˆ°åˆ™åŽ»å…¨å±€çŽ¯å¢ƒä¸­å¯»æ‰¾, å¦‚æžœæœ€ç»ˆæ‰¾ä¸åˆ°, åˆ™æŠ›å‡ºé”™è¯¯.

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜, å¦‚æžœå‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­æŽ¥å—çš„å‚æ•°ä¸ªæ•°å°äºŽå½¢å‚, é‚£ä¼šæ€Žæ ·? è¿™ç§å‡½æ•°åŠæˆå“ä¹Ÿä¸èƒ½æ˜¯ä¸ªé”™è¯¯, æ‰€ä»¥åº”è¯¥ç›´æŽ¥è¿”å›žç›®å‰çš„çŠ¶æ€, å½“å…¶å†è¢«ä¼ å…¥å‰©ä½™å‚æ•°æ—¶å€™, å¯ä»¥è¢«æ­£å¸¸æ‰§è¡Œ.

å†è€ƒè™‘ä¸€ä¸ªé—®é¢˜, å¦‚ä½•è®¾ç½®å¯å˜å‚æ•°? æ¯”å¦‚ `f(s y & xs)` å¯ä»¥æŽ¥å—è‡³å°‘ä¸¤ä¸ªå‚æ•°. äºŽæ˜¯å¢žåŠ å‡ è¡Œä»£ç :

```c
if (strcmp(sym->sym, "&") == 0) {
  if (f->formals->count != 1) {
    lval_del(a);
    return lval_err("Function format invalid. "
      "Symbol '&' not followed by single symbol.");
  }
  lval* nsym = lval_pop(f->formals, 0);
  lenv_put(f->env, nsym, builtin_list(e, a));
  lval_del(sym); lval_del(nsym);
  break;
}
```

åˆ¤æ–­å¦‚æžœå‚æ•°é‡Œé¢æœ‰ `&` ç¬¦å·, åˆ™å°†åŽé¢æŽ¥å—çš„æ‰€æœ‰å˜é‡å­˜åˆ°åŽä¸€ä¸ªå½¢å‚ä¸­, ä½œä¸ºä¸€ä¸ª list. å½“ç„¶ä¹Ÿè¦å°å¿ƒå¦‚æžœåªæ”¶åˆ°æœ€å°‘çš„å‚æ•°æƒ…å†µ:

```c
if (f->formals->count > 0 &&
  strcmp(f->formals->cell[0]->sym, "&") == 0) {
  if (f->formals->count != 2) {
    return lval_err("Function format invalid. "
      "Symbol '&' not followed by single symbol.");
  }
  lval_del(lval_pop(f->formals, 0));
  lval* sym = lval_pop(f->formals, 0);
  lval* val = lval_qexpr();
  lenv_put(f->env, sym, val);
  lval_del(sym); lval_del(val);
}
```

è®¾ç½®æœ€åŽçš„å½¢å‚ä¸ºç©ºåˆ—è¡¨.

```
lispy> def {add-mul} (\ {x y} {+ x (* x y)})
()
lispy> add-mul 10 20
210
lispy> add-mul 10
(\ {y} {+ x (* x y)})
lispy> def {add-mul-ten} (add-mul 10)
()
lispy> add-mul-ten 50
510
lispy>
```

é€šè¿‡ `def {a} (\ {x y} {* x y})` è¿™ç§æ–¹å¼ä¸ç¬¦åˆå¹³æ—¶çš„å‡½æ•°å®šä¹‰, å¹³æ—¶æˆ‘ä»¬ä¹ æƒ¯è¿™ä¹ˆå†™: `def func(a b) { a+b }` å¯¹åº”åˆ° lisp é‡Œåº”è¯¥æ˜¯ `func {funcname x y} {* x y}`. æ‰€ä»¥éœ€è¦ä¸€ç‚¹è¯€çª:

```
\ {args body} {def (head args) (\ (tail args) body)}
def {fun} (\ {args body} {def (head args) (\ (tail args) body)})
fun {add-together x y} {+ x y}
```

è¿™ä¸ª lambda æŽ¥å—ä¸¤ä¸ªå‚æ•°, å‡½æ•°å+å‚æ•° å’Œ å‡½æ•°ä½“, ç„¶åŽå°†*å‡½æ•°ä½“+å‚æ•°* æ‹†åˆ†, å†ç»„åˆæˆæ–°çš„ lambda å°±å¯ä»¥å®žçŽ°æˆ‘ä»¬çš„ç›®æ ‡.

### å‡½æ•°æŸ¯é‡ŒåŒ–

åå­—å¾ˆçŽ„ä¹Ž, å°±æ˜¯ä¸ºäº†è§£å†³å‡½æ•°æŽ¥å—ä¸€ä¸ªå‚æ•°, å¦‚ä½•å°†å¤šä¸ªå‚æ•°åŽ‹ç¼©æˆä¸€ä¸ªä¼ è¿›åŽ», å’Œå‡½æ•°æŽ¥å—å¤šä¸ªå‚æ•°, å¦‚ä½•å°†ä¼ å¦‚çš„ä¸€ä¸ªåˆ—è¡¨å±•å¼€ä¼ è¿›åŽ».

æ‰€ä»¥:

```
fun {unpack f xs} {eval (join (list f) xs)}
fun {pack f & xs} {f xs}
```

```
lispy> def {uncurry} pack
()
lispy> def {curry} unpack
()
lispy> curry + {5 6 7}
18
lispy> uncurry head 5 6 7
{5}
```
